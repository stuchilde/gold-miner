> * 原文地址：[Modernization of Reactivity](https://davidwalsh.name/modernization-reactivity)
* 原文作者：[ Kris Zyp](https://kriszyp.name/)
* 译文出自：[掘金翻译计划](https://github.com/xitu/gold-miner)
* 译者：[Liz](http://lizwangying.github.io/)
* 校对者：





近十年来，在 JavaScript 的进化路上，响应式编程说可以说是它的最大变革了。前端开发极大地从中它的简洁性中获益，编写用户界面时代码实时响应，消除了更新UI时大量易出错的代码。然而，尽管受欢迎程度增加了，工具和技术和当今浏览器的配合的并不是很好， 比如 web API、语言能力、最优算法的性能、可伸缩性、语法，和长期稳定。在这篇文章中，我们来看看一些已有的新技术、技巧，比如这个新的库—— [Alkali](http://kriszyp.github.io/alkali/) 。

接下来我们将要介绍的技术呢，包含了队列渲染、基于细粒度的响应，ES6 的响应式生成器和表达式，本地 web 响应式组件，还有可逆的定向流动。这不仅仅只是一时兴起的编程技术，他可是结合了浏览器和深入的研究和开发，才能有现在的卓越表现：更简洁的代码，与新组件的协调能力和更完美的封装。   
[![](https://github.com/kriszyp/todomvc-perf-comparison/raw/master/sampleResults.png)](https://github.com/kriszyp/todomvc-perf-comparison/)   
那么我们就来举几个简单的例子来说明  Alkali （你也可以直接跳到 Alkali 的几个完整案例——做 mvc 应用，你不得不知道的事）。或许我们能够构建的，不仅是标准的元素结构，还有最重要的特性：在资源消耗最低的基础上能够快速展示。这些前沿技术的确带来了可扩展的好处、高效率和可观的效益。在各种新的 library 的配合下，最直接具有预见性和稳定性的结构就是构建基于标准的浏览器元素/组件的API。

## Push-Pull Reactivitiy （响应式 Push-Pull）

扩展响应式编程的关键就是编程框架的数据流。接近原生的响应式编程即仅使用 Observable (观察者)或者监听器，来将每一次更新以流的形式，push 到每一个对应的监听中。这种快速响应会导致过度计算，任何多状态多层的状态来更新就会导致中间重复计算很多你没有预计到的。最好就是使用 "pull"-based 的计算方法，它更加可扩展，所有的数据的计算都在懒加载，直到下载流请求或"pull"最后的值。Observer （订阅者）可以请求运用 de-bouncing 请求数据，直到队列被通知数据已经被改变。

基于响应式 Pull 的方法也可以结合使用缓存。当数据被计算出来时，缓存结果，然后 upstream 的改变发出通知以用来确保 downstream 的缓存数据失效，保证数据是实时的。这种基于响应式 Pull 的缓存失效方案与 REST 的设计架构遵循一致的设计架构原则，其中的可扩展网络设计、以及当今浏览器渲染流程。

然而，使用这种方案的最佳情境是当一些项目有了新的改变并逐步更新当前的状态。这种特殊情境下使用，逐步增加、删除、更新集合中的元素是非常有效的方法。与其他一起混合搭配使用会更好哦，比如：数据主要是来自观察者，但是增量更新可以通过实时数据流作为一个优化。

## Queued Rendering （队列渲染）

想要依赖基于响应式 Pull 在响应式的 app 中以提高应用效率，最重要是的关键就是确保渲染的执行消耗最小。通常情况下，应用程序的多个部分可能都在更新状态，如果渲染是同步的，任何状态变化都立即执行，这很容易导致界面抖动，并且执行效率低。通过排队渲染我们可以确保即使多个状态发生变化，渲染依然是最小化的。

排队行为或消除抖动是一种相对常见的和众所周知的技术。然而，对于优化排队渲染，浏览器实际上提供了一个很好的替代通用回弹功能。由于它的名字叫『 requestAnimationFrame 』，所以常被认为是动画相关的库，但实际上这个这么潮的API在队列渲染状态改变最最完美的。它是宏观事件的 Task ，所以任何微小的 Task ，比如承诺决议将被允许首先完成。考虑到最后的渲染，选项卡/浏览器的可见性，电流负荷等等，它还允许浏览器来确定精确的最佳时机来渲染新的变化。它在休息状态下可以立即执行回调(通常是毫秒级)，在适当的帧速率在顺序呈现的情况下，甚至可以完全延迟隐藏一个页面/选项卡。事实上，通过『 requestAnimationFrame 』的队列渲染状态的改变，当视图需要更新时再渲染，我们实际上优化渲染流后，以精确的时间和序列/路径渲染后给浏览器本身使用的。这种方法可以确保我们正在与浏览器渲染互补的方式高效、及时、不绘制多余的布局或重绘。

这可以被认为是两个阶段的渲染方法。第一阶段是处理事件程序的响应，我们更新规范化数据来源，进而使依赖这些数据的衍生数据或者组件失效。无效UI组件都是排队等候渲染。第二阶段就是组件的渲染阶段，检索他们的必要的数据和渲染它们。

![](https://kriszyp.files.wordpress.com/2015/11/two-phase-rendering.png?w=780)

Alkali 通过利用 [渲染器对象](https://github.com/kriszyp/alkali#renderers) 渲染队列， 实时与响应式的输入数据和对应的元素相关联（在 alkali 中称为『变量』）， 然后通过『 requestAnimationFrame 』机制重新渲染队列状态。这意味着任何数据都与队列的效果图相绑定。这意味着我们可以创建构造函数，参数『变量』装载响应式的值，并连接到一个元素（这里我们创建一个『 』）。示例代码如下：

    import { Variable， Div } from 'alkali'

    // 创建一个变量
    var greeting = new Variable('Hello')
    // 创建一个 div ，里面与变量相关联
    body.appendChild(new Div(greeting)) // 注意，这是一个标准的 div 元素
    // 现在变量的更新会实时相应到 div 中
    greeting.put('Hi')
    // 这里的渲染机制会在 div 中排队渲染
    greeting.put('Hi again')

这里的 div 使用了『 requestAnimationFrame 』机制，将随时自动更新 div 的状态改变，并且多个更新不会导致多个渲染，只有最后一个状态将会被渲染。

## Granular Reactivity （细粒度的响应）

单纯的响应式编程允许单个信号或通过一个系统变量使用和传播。然而，在精通熟悉命令式编程的程序猿们，使用响应式 diff-based 这样的框架，比如 ReactJS，使用一个虚拟的 DOM ，也非常受欢迎。它允许我们编写一个应用程序或许必要使用的代码使用这种方法。任何应用程序状态改变时，组件只是重新渲染，一旦组件输出与先前的输出不一致则进行更改。而不是数据流产生明确的变化再渲染UI，还得比较重新运行的输出与先前的状态。

虽然这是一个非常熟悉的和方便的编码规范，但是它牺牲了巨大代价：内存和性能。响应式对比需要一个完整副本的渲染输出和复杂的对比算法来确定差异和减轻过度 DOM 重写。这个虚拟 DOM 通常需要2到3倍的内存使用和对比算法增加类似的开销相比才能直接确定 DOM 的改变。

另一方面，真正的响应式编程显式地定义变量或值可以改变，并连续输出这些值的变化。这并不需要任何额外的开销或对比算法，所指定的输出直接在代码中指定联系。

可调式性得益于细粒度的功能活性代码流。调试命令式编程涉及重建的条件和重建代码块的步骤，需要复杂的推理评估状态值得改变(以及它如何会是错误的)。反应流可以静态检查，在任何时候我们都可以得到完整的与输入对应的可视性图形界面输出。

还有，使用真正的响应式编程技术不是一个深奥或迂腐的计算机科学技术，它其实在程序的可扩展性、提升速度、加快响应能力、便于调试应用程序流有着显著的好处。

## Canonical and Reversible Data （规范和数据的可逆） 

细粒度的响应显式流也可以与反向数据流实现双向绑定，这样下载流数据的消费者，如输入元素，可以请求上传数据变化，不需要额外的配置，连接，或必要的逻辑。这使它非常容易建立和绑定表单的输入控件。

响应式编程的一个重要原则是『来源的真实一致性』，在数据来源和派生数据之间的区别有一个明确的规范。响应式的数据可以称为一个的指向性的数据。这对数据管理是至关重要的。如果同步多个数据状态，并没有明确的来源和派生数据，会使数据管理混乱，导致多种声明管理问题。

Single-directional （单向型）数据流与集中式数据流的变化，与响应式比较有关，是一种适当的有向图的数据。

然而，一个有向图与规范的数据来源不能够决定数据只能通过图形传达这一种方法。细粒度的响应可以支持数据的可逆。可逆性，下游方向仍然可以保留通过定义数据变更的通知改变已经发生或发起(过去)，而相比之下，一个上游数据变化是定义为一个更改请求开始(在未来，和可撤销的)。请求更改导出数据仍然可以做，只要有一个反向变换传播请求源(可逆数据遍历或转换通常被称为一个“镜头”功能的术语)。规范化数据变化仍然发生在数据源上，即使启动/下游消费者请求的。与此流的明显区别，典型的有向图源和派生数据仍保存，保持状态的一致性，同时仍然允许封装与个人数据实体交互，不管他们是否。实际上，这简化了开发用户输入和表单的管理，鼓励输入组件的封装。

## 与时俱进的 DOM 扩展 （『Web 组件』） 

学习编程要具有远见，代码的可维护性是至关重要的，你的代码要在 JavaScript 的生态系统中随着众多新技术的不断涌现还能够做到可维护这是极具挑战性的。三年后哪家新框架能够闪耀夺目？从过往的历史来看，这是很难预测的。在这种杂乱的情况下我们怎么发展？最可靠的方法是减少依赖特定api库，并最大化我们的依赖标准浏览器api和架构。使用新兴组件 api 和功能（就是『web组件』）才更加可行。

响应式结构的最佳定义不应该是规定一个特定的组件体系结构，应灵活地使用原生或第三方组件，这样才能在未来的发展中最大化地生存。然而，尽管我们极力降低耦合，某种程度的耦合可能是有用的。特别是当能够直接使用变量作为值或属性的输入，无疑是比创建数据绑定后再获来的方便。与元素/组件生命周期的集成、当元素被删除或分离时通知，便于自动清理的依赖性和监听机制，为了防止内存泄漏，减少资源消耗，简化组件使用。

还有，当今的浏览器使得 web 组件集成与原生元素的集成完全可行。如今可以从现有的 HTML 扩展原型上定义真正基于 dom 的定制类，通过响应式可勘测变量的构造函数（ reactive variable-aware constructors ），『 MutationObserver 』界面（和未来潜在的 web 组件回调）让我们能够监控元素什么时候分离的（还有附加的）。ES5 的 getter / setter 很好地表明了允许我们适当地扩展和复制自然元素的样式属性。

Alkali 定义了一系列 DOM 构造函数/类定义了这些功能。这些类是原生 DOM 类的最小扩展，它的构造函数参数支持变量输入的属性，并且能够将变量自动清理。在响应式懒惰加载/基于响应式 Pull 中，这意味着元素的数据改变动态可见，一旦分离，将不再触发任何通过其依赖的输入。这就导致一个元素的创建和扩展与自动自己清除监听。例如:

    let greetingDiv = new Div(greeting)
    body.appendChild(greetingDiv)
    // greeting 的改变会自动创建一个绑定监听
    ...
    body.removeChild(greetingDiv)
    // greeting的绑定/监听会被清理掉

## Reactive Generators （响应式生成器）

不光是 web API 在响应式编程有着重大的提高，ECMAScript 语言它本身就有着激动人心的新功能，它的语法的优化使得更容易编写响应式代码。其中一个强大的新特性是生成器（ generators ），它提供了一个优雅的和直观的代码流交互的语法。也许处理响应式数据的最大的不便就是 JavaScript 是经常需要回调函数来处理状态改变。然而，ECMAScript 新的生成器函数能够暂停，恢复，并重新启动一个函数，函数可以利用响应式数据的输入以标准的顺序语法，暂停和恢复任何异步输入。生成器还可以自动订阅相关的输入，当输入变化则重新执行该函数。通过生成器可以很好地控制，这个函数执行（双关语！下文中提到的函数 `yield` ），直观和浅显易懂的语法就能够控制复杂的变量组合输入。（这句话怎么翻译呀？感觉好别扭，怎么翻译成含有双关语意的句子）

生成器可以提前预测到回调函数中的取消操作，支持使用一个直观的顺序语法。生成器不仅可以进一步在异步输入数据时采取暂停和恢复，还可在任何输入值变化时重新启动。在任何变量的输入之前通过使用 `yield` 操作符，可以对相应的代码监听其变量的变化，并返回变量当前值产生时的表达式。

让我们来看看这是如何实现的，在 Alkali 中，生成器函数可以作为输入变量的转换，创建一个响应式函数 `react` ，它会输出一个新的综合的变量。 `react` 函数充当生成器的控制器，来控制响应式变量。下面来看一个分步讲解举例：

    let a = new Variable(2)
    let aTimesTwo = react(function*() {
      return 2 * yield a
    })

生成器提供的 `react` 操作符负责处理执行代码。生成器返回一个 iterator ，它与生成器进行交互时被 `react` 启动。直到生成器预计到 `yield` 操作符的出现时，代码会立刻执行 `yield` 操作符，iterator 的返回值交给给 `yield` ， `yield` 再返回给 `react` ，这时将控制权交给 `react` 函数。在这种情况下， `a ` 变量将被返回给 `react` 函数，真是身兼多职有木有。

首先，它可以订阅或听提供的响应式变量（如果它是的话），所以它在任何改变发生时都能够通过重新执行的方式立即做出响应。第二，它可以得到当前状态或反应变量的值，当 resume 时它可以返回 `yield` 表达式的结果。最终返回前， `react` 函数可以检查这个响应式变量是否是异步的、是否持有约定值，如果必要还可等待约定值返回之后恢复执行函数。一旦拿到当前的状态，生成器函数就会恢复执行 `2 ` 的值，将它返回给 `yield a ` 表达式。如果有更多的 `yield` 表达式，它们会顺序执行，并以同样的方式解决。在这种情况下，生成器将返回一个 `4 ` ，然后结束生成器序列（直到 a 变化或重复执行）。

Alkali `react` 函数被封装在另一个符合的响应式变量中，任何变量的变化不会触发重新执行操作，除了下载数据访问或请求。

Alkali 生成器函数还可以直接使用在元素构造函数中，定义一个渲染功能。它在任何值发生变化时，都会自动重新执行。在这两种情况下，我们在所有变量前面使用前面提到的 `yield`。 

    import { Div， Variable } from 'alkali'
    let a = new Variable(2)
    let b = new Variable(4)
    new Div({
      *render() {
        this.textContent = Math.max(yield a， yield b)
      }
    })

这将创建了一个 `` ，文本内容为 `4 ` （两个输入的最大值），我们可以更新其中任一变量，它将重新执行。

    a.put(5)

`` 现在的内容将被更新为 `5 ` .

生成器还不是普遍兼容所有的浏览器（比如 IE 浏览器和 Safari 就不支持），但是生成器可以搭载或者在其他工具模拟下实现（比如 Babel 或其他工具）。

### Properties and Proxies （属性和代理）

Reactivity 响应式地绑定到对象的属性上是很重要的一个方面。但是封装属性更改通知，需要的不仅仅是当前的标准属性访问返回的属性值。因此，被动的绑定属性或变量需要详细的语法。

然而，ECMAScript 另一个激动人心的新特性是代理，它允许我们定义一个对象，用来拦截所有属性访问和修改自定义功能。这是强大的功能，可用于通过普通属性访问返回活性属性变量，更方便不说，reactive 对象也是使用惯用的语法。

不幸的是代理不像 Babel 那么容易通过代码编译器模拟。模拟代理不仅需要 transpiling 代理构造函数本身，还需要任何代码访问代理，所以模拟器没有了原生语言的支持将是不完整的，它会执行莫名缓慢并且代码臃肿，由于需要大量的执行 transpile ，过滤应用程序的每个属性。但更有针对性地执行 transpile 也是可行的。让我们来看看。

## Reactive 表达式

EcmaScript 不断推进的同时，Babel 及其插件等工具也在与时俱进，这给我们很大机会来创建新的编译语言特性。当生成器可以很酷炫地使用 Babel 插件创建一个函数去执行异步操作和响应式地立即执行的操作，使用 ECMAScript 语法将属性绑定，代码可以转化为完全响应式的数据流。这就比简单的执行 re-execution 要复杂很多，比如表达式的输出与输入之间可定义一些操作，比如可逆操作符，响应式的属性，还有使用简单的惯用的表达式可以生成响应式的任务。

这里有[一个独立的项目](https://github.com/kriszyp/babel-plugin-transform-alkali) ，它使用了基于 Alkali 的插件 Babel 转换响应式表达式。使用这个我们可以编写一个表达式用 `react` 作为参数调用/操作符：

    let aTimes2 = react(a * 2)

这里的 `aTimes2` 的值与输入的变量 `a` 的乘法运算值相绑定。如果我们改变 `a` 的值（使用 `a.put()` 就可改变它的值），`aTimes2` 将会自动更新值。事实上由于我们使用了完美定制的 `react` 操作符，所以这个数据还是可逆的。我们可以为 `aTimes2` 指定一个新的值，比如 `10` ，那么 `a` 的值将自动更新为 `5`。

如上所述，代理模拟整个代码库几乎是不可能的，但是在我们响应式表达式中呢，响应式变量编译属性的语法去控制属性的就是洒洒水的小事啦。还有更厉害的，其他的操作符还可以将变量 transpile 成可逆的。例如，我们可以写复杂的纯响应式代码的组合:

    let obj， foo
    react(
      obj = {foo: 10}， //我们可以创建新的响应式对象
      foo = obj.foo， //得到一个响应式对象的属性
      aTimes2 = foo //将它分配给 aTimes2 （绑定到上边的表达式中）
      obj.foo = 20 //更新对象（就会响应式地将值传递给 foo ， aTimes2 ，还有上面的 a ）
    )
    a.valueOf() // -> 10

##技术要与时俱进

Web开发一直是在不断变化和进步，它的每一次进步都激动人心。Reactivity 是当今应用程序中先进的编程理念，它随着新技术的发展和现代浏览器功能的不断进化，它的语言和api也在与时俱进。他们一起使用过可以使 web 开发超前迈进。对于未来的发展中的无限可能我是满满滴激动，并希望这些想法能够实现，未来的新工具对于 web 开发的改进我真是拭目以待。

Alkali 已被我们的工程师团队使用， 在 [Doctor Evidence](https://drevidence.com/) 网站中我们用它开发的。我们一直在努力探索构建交互式和响应的工具，它在这个网站中负责查询和分析临床医学研究的大型数据集。这是一个有趣的挑战，要保证流畅的用户界面的同时还要处理复杂和庞大的数据，它其中的许多方法对我们很有用，我们采用新的浏览器技术开发我们的网络软件。没有别的，我们只是希望 Alkali 可以作为一个例子来激励 web 开发更进一步。



